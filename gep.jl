using SDDP, CSV, DataFrames, FileIO, Gurobi, Serialization
folder = "/Users/akulbansal/Library/CloudStorage/OneDrive-NorthwesternUniversity/NU_office/r/stoch/stoch_code/sddp_remote/sddp_data/data/"

"""
Originally from the paper:
Jin et al. (2011) Modeling and solving a large-scale generation expansion planning problem under uncertainty

Variable mapping:

Code -> Original paper
x[g] -> U[g, y]: Number of generators of type g to be built in year y
y[g,s] -> L[g, s, w]: The power generated by generator of type g per hour in
                      sub-period s for scenario w
u[s] -> E[s, w]: The unserved load per hour in sub-period s for scenario w.
                 Units are MW.
h[1:G, 1:binCoeff]: variable h is the state variable that captures the cumulative number of generators of type g
                    the second index denotes the binarization of the state variables to ensure that we have convergence
demand[s] -> d[s, w] demand per hour in sub-period s for scenario w. Units are MW


Parameters that are used in the model:

genCap -> n_g^max: generator capacity (max output rating of generator of type g per hr)
genMax -> u_g^max: maximum number of generators that we can build
dem_sample
gas_prince
genHeat
genEff
omCost


"""




function gep(
    T::Int64,
    G::Int64,
    S::Int64,
    lb::Number,
    binCoeff::Number,
    invCost::Matrix{Float64},
    genCost::Matrix{Float64},
    genMax::Vector{Int64},
    genCap::Vector{Float64},
    genHeat::Vector{Int64},
    genEff::Vector{Float64},
    omCost::Vector{Float64},
    hours::Vector{Float64},
    support::Dict{Int64, Vector{Vector{Any}}},
    threads::Int64,
)

    #T: number of stages in the problem
    #G: number of generators
    #ub: upper bound in the problem
    #invCost: investment cost for (time, generator)
    #genCost: operational cost for (time, generator)
    #params: parameters for generators
    #S: set of subperiods


    model = SDDP.LinearPolicyGraph(
        stages = T,
        sense  = :Min,
        lower_bound = lb,
        optimizer = Gurobi.Optimizer,
        solver_threads = threads
    ) do sp, stage

        #local variables
        @variable(sp, 0 <= x[1:G], integer = true)  #number of generators to use
        
        #variable y here represents 10 MWHs, other parameters are scaled accordingly
        rescale          = 10.0
        @variable(sp, 0 <= y[1:G, 1:S])                                                 #electricity generated per hour in each subperiod
        @variable(sp, 0 <= u[1:S])                                                      #unmet demand in each subperiod

        #state variables
        @variable(sp, 0 <= h[1:G, 1:binCoeff], Bin, SDDP.State, initial_value = 0)
        @variable(sp, demand[1:S])                                                      #random parameter for demand for each subperiod

        #generation capacity -> Constraint (3) in Jin et al. paper
        @constraint(
            sp,
            genCapacity[g in 1:G, s in 1:S],
            (genCap[g]/rescale)*sum(2^(m-1)*h[g, m].out for m in 1:binCoeff) >= y[g, s]
        )
    
        #limitation on total number of generators -> Constraint (1) in Jin et al. paper
        @constraint(
            sp,
            genLimit[g in 1:G],
            sum(2^(m-1)*h[g, m].out for m in 1:binCoeff) <= genMax[g]
        )

        # demand satisfaction -> Constraint (2) in Jin et al. paper
        @constraint(
            sp,
            demSatisfy[s in 1:S],
            sum(rescale*y[g, s] for g in 1:G) + u[s] == demand[s]
        )

        #constraint connecting one stage with the other
        @constraint(
            sp,
            flow[g in 1:G],
            sum(2^(m-1)*h[g, m].out for m in 1:binCoeff) == x[g] + sum(2^(m-1)*h[g, m].in for m in 1:binCoeff)
        )


        SDDP.parameterize(sp, support[stage]) do sample
            dem_sample = sample[1:end-1]
            gas_price  = sample[end]
            rate = 0.0{}
            if stage != 1
                #cost for generator of type 2
                genCost[stage, 2]          = ((gas_price/1000)*(genHeat[2]/genEff[2]) + omCost[2]*1e-6*(1+0.03)^(stage-1))/((1+rate)^(stage-1))
                
                #cost for generator of type 3
                #the division by 1000 here is because we are converting gas price from bmtu to btu  
                genCost[stage, 3]          = ((gas_price/1000)*(genHeat[3]/genEff[3]) + omCost[3]*1e-6*(1+0.03)^(stage-1))/((1+rate)^(stage-1))
            end

            #three cost components:
                #fixed cost of creating a generator
                #cost of producing electricity
                #cost of missing demand

            @stageobjective(
                sp,
                sum(invCost[stage, g]*x[g] for g in 1:G) 
                + sum(rescale*hours[s]*genCost[stage, g]*y[g, s] for g in 1:G for s in 1:S) 
                + sum(hours[s]*invCost[stage, G+1]*u[s] for s in 1:S)       #penalty for missing demand
            )
            JuMP.fix.(demand, dem_sample)
        end
    end
    return model
end


function gep_data_load(folder, fixCost_file, varCost_file)

    fix_cost = CSV.read(folder*fixCost_file, DataFrame)
    var_cost = CSV.read(folder*varCost_file, DataFrame)
    # params   = CSV.read(folder*param_file, DataFrame)

    select!(fix_cost, Not(:Time))
    select!(var_cost, Not(:Time))


    #rows represent the year number and coloumns represent different generators
    #last column represents the cost of unmet demand
    #cost of unmet demand has also been scaled by a factor of 1e-6s
    #the scaling by a factor of 1e-6 has already been done in the file
    fix_cost_matrix = Matrix(fix_cost)
    var_cost_matrix = Matrix(var_cost)

    genMax = [4, 10, 10, 1, 45, 4]                              
    genCap = [1130.0, 390.0, 380, 1180, 175, 560]
    genHeat = [8844, 7196, 10842, 10400, 0, 8613]
    genEff = [0.4, 0.56, 0.4, 0.45, 1, 0.48]
    omCost = [4.7, 2.11, 3.66, 0.51, 5, 2.98]
    hours = [271.0, 6556.0, 1933.0]

    return fix_cost_matrix,var_cost_matrix,genMax, genCap, genHeat, genEff, omCost, hours


end

function gep_runs(outpath, folder, id, rep, st, scens, timeL)
    prefix = "gep"
    fixCost_file =  "gep_fixed_cost_jou.csv"
    varCost_file =  "gep_varCost_jou.csv"
    fix_cost_matrix, var_cost_matrix, genMax, genCap, genHeat, genEff, omCost, hours = gep_data_load(folder, fixCost_file, varCost_file)
    inFile = folder*prefix*"_$(id)_$(rep)_$(st)_$(scens).jls"
    support = open(inFile, "r") do f
        deserialize(f)
    end
    T = st
    G = 6
    S = 3
    binCoeff = 5
    nonRandomGens = [1, 3, 4, 5, 6]
    lb = 0    
    gep_model = gep(T,G,S,lb,binCoeff,fix_cost_matrix,var_cost_matrix,genMax,genCap,genHeat,genEff,omCost,hours,support)
end

function train_il(model, time_limit, record_interval = 3600, mipgap = 1e-4, bdIters = 50, doAdd = false)

    output_dict = SDDP.train(
        model;
        duality_handler = SDDP.LaporteLouveauxDuality(),
        stopping_rules = [SDDP.BoundStalling(bdIters, 1e-4), SDDP.TimeLimit(time_limit)],
        forward_pass = SDDP.DefaultForwardPass(),
        cut_type = SDDP.SINGLE_CUT,
        print_level = 2,
        dashboard = false,
        record_every_seconds = record_interval,
        add_to_existing_cuts = doAdd,
        mipgap = mipgap
        )

    return output_dict
end

function train_lagrangian(model, time_limit, record_interval = 3600, mipgap = 1e-4, bdIters = 50, doAdd = false)


    output_dict = SDDP.train(
        model;
        duality_handler = SDDP.LagrangianDuality(),
        forward_pass = SDDP.DefaultForwardPass(),
        stopping_rules = [SDDP.BoundStalling(bdIters, 1e-4), SDDP.TimeLimit(time_limit)],
        cut_type = SDDP.SINGLE_CUT,
        print_level = 2,
        record_every_seconds = record_interval,
        add_to_existing_cuts = doAdd,
        mipgap = mipgap
        )
    return output_dict
end

function train_angulo(model, time_limit, record_interval = 3600, mipgap = 1e-4, bdIters = 50, doAdd = false)

    output_dict = SDDP.train(
        model;
        duality_handler = SDDP.LaporteLouveauxDuality(),
        stopping_rules = [SDDP.BoundStalling(bdIters, 1e-4), SDDP.TimeLimit(time_limit)],
        forward_pass = SDDP.DefaultForwardPass(),
        backward_pass = SDDP.AnguloBackwardPass(),
        cut_type = SDDP.SINGLE_CUT,
        print_level = 2,
        dashboard = false,
        record_every_seconds = record_interval,
        add_to_existing_cuts = doAdd,
        mipgap = mipgap
        ) 

    return output_dict

end

function train_angulo_lagrangian(model, time_limit, record_interval = 3600, mipgap = 1e-4, bdIters = 50, doAdd = false)

    """
    
    """
    output_dict = SDDP.train(
        model;
        duality_handler = SDDP.LagrangianDuality(),
        forward_pass    = SDDP.DefaultForwardPass(),
        backward_pass   = SDDP.AnguloBackwardPass(),
        stopping_rules = [SDDP.BoundStalling(bdIters, 1e-4), SDDP.TimeLimit(time_limit)],
        cut_type        = SDDP.SINGLE_CUT,
        print_level     = 2,
        record_every_seconds = record_interval,
        add_to_existing_cuts = doAdd,
        mipgap = mipgap
    )

    return output_dict
end

function train_angulo_sb(model, time_limit, record_interval = 3600, mipgap = 1e-4, bdIters = 50, doAdd = false)  

    output_dict = SDDP.train(
        model;
        duality_handler = SDDP.LaporteLouveauxDuality(),
        stopping_rules = [SDDP.BoundStalling(bdIters, 1e-4), SDDP.TimeLimit(time_limit)],
        forward_pass = SDDP.DefaultForwardPass(),
        backward_pass = SDDP.SBendersBackwardPass(),
        cut_type = SDDP.SINGLE_CUT,
        print_level = 2,
        dashboard = false,
        record_every_seconds = record_interval,
        add_to_existing_cuts = doAdd,
        mipgap = mipgap
        ) 

    return output_dict

end

function train_sb_lagrangian(model, time_limit, record_interval = 3600, mipgap = 1e-4, bdIters = 50, doAdd = false)

    """
    
    """


    output_dict = SDDP.train(
        model;
        duality_handler = SDDP.LagrangianDuality(),
        forward_pass    = SDDP.DefaultForwardPass(),
        backward_pass   = SDDP.SBendersBackwardPass(),
        stopping_rules = [SDDP.BoundStalling(bdIters, 1e-4), SDDP.TimeLimit(time_limit)],
        cut_type        = SDDP.SINGLE_CUT,
        print_level     = 2,
        record_every_seconds = record_interval,
        add_to_existing_cuts = doAdd,
        mipgap = mipgap
    )

    return output_dict
end


function train_method(
    model,
    duality_handler,
    forward_pass,
    backward_pass,
    sampling_scheme,
    time_limit,
    iter_limit,
    mipgap,
    iter_pass,
    M = 1,
    delta = 0.05,
    fpass_type = 1,
    final_run = false,
    type1_prob = 1.28,
    type2_prob = 1.28,
    seed = nothing
)


    #fpass_type = 2 means Nested Benders algorithm
    #fpass_type = 1 means SDDiP algorithm

    outputs = nothing

    if fpass_type == 2
        if iter_limit < 1
            # println("       smkp_NES.jl: train function without the iteration limit ")
            outputs = SDDP.train(
                model;
                duality_handler = duality_handler,
                forward_pass    = forward_pass,
                backward_pass   = backward_pass,
                sampling_scheme = sampling_scheme,
                stopping_rules  = [SDDP.TimeLimit(time_limit), SDDP.NBBoundStalling(delta)],
                mipgap          = mipgap,
                iter_pass       = iter_pass,
                M               = M,
                print_level     = 2,
                final_run       = final_run)
        else
            # println("       smkp_NES.jl: the second train function is choosen")
            outputs = SDDP.train(model,
                duality_handler = duality_handler,
                forward_pass    = forward_pass,
                backward_pass   = backward_pass,
                sampling_scheme = sampling_scheme,
                stopping_rules  = [SDDP.IterationLimit(iter_limit), SDDP.NBBoundStalling(delta), SDDP.TimeLimit(time_limit)],
                mipgap          = mipgap,
                iter_pass       = iter_pass,
                M               = M,
                print_level     = 2,
                final_run       = final_run)
        end
    else
        if iter_limit < 1
            # println("       smkp_NES.jl: train function without the iteration limit ")
            outputs = SDDP.train(
                model;
                duality_handler = duality_handler,
                forward_pass    = forward_pass,
                backward_pass   = backward_pass,
                sampling_scheme = sampling_scheme,
                stopping_rules  = [SDDP.TimeLimit(time_limit), SDDP.TitoStalling(type1_prob, type2_prob, delta)],
                mipgap          = mipgap,
                iter_pass       = iter_pass,
                M               = M,
                print_level     = 2,
                final_run       = final_run,
                seed            = seed)
        else
            # println("       smkp_NES.jl: the second train function is choosen")
            outputs = SDDP.train(model,
                duality_handler = duality_handler,
                forward_pass    = forward_pass,
                backward_pass   = backward_pass,
                sampling_scheme = sampling_scheme,
                stopping_rules  = [SDDP.IterationLimit(iter_limit), SDDP.TitoStalling(type1_prob, type2_prob, delta), SDDP.TimeLimit(time_limit)],
                mipgap          = mipgap,
                iter_pass       = iter_pass,
                M               = M,
                print_level     = 2,
                final_run       = final_run,
                seed            = seed)
        end
    end

    

        
    # # println(typeof(outputs[1]))
    sddp_bound  = outputs[1].bb 
    sddp_simval = outputs[1].cumm_list[end]

    println("the bound attained from sddp:            $(sddp_bound)")
    println("the simulation value attained from sddp: $(sddp_simval)")
    println("================== end ====================")

    return outputs

end




function gep_method_runs(
    folder,
    filepath,
    duality_handler,
    forward_pass,
    backward_pass,
    sampling_scheme,
    reps,
    id,
    st,
    scens,
    time_limit = 120,
    iter_limit = 2,
    mipgap = 1e-4,
    iter_pass = 1,
    threads = 1,
    M = 1,
    delta = 0.05,
    postSim = 50,
    simTime = 3600.0,
    final_run = false,
    type1_prob = 1.28,
    type2_prob = 1.28,
    seed = nothing)

    """
    final_run: for sddip algo, traversing the entire scenario tree to get deterministic bounds
    """
    



    prefix = "gep"
    fixCost_file =  "gep_fixed_cost_jou.csv"
    varCost_file =  "gep_varCost_jou.csv"
    fix_cost_matrix,var_cost_matrix,genMax, genCap, genHeat, genEff, omCost, hours = gep_data_load(folder, fixCost_file, varCost_file)
    inFile = folder*prefix*"_$(id)_$(reps)_$(st)_$(scens).jls"
    support = open(inFile, "r") do f
        deserialize(f)
    end

    T = st
    G = 6
    S = 3
    binCoeff = 6
    lb = 0

    build_time =  @elapsed begin
    gep_model = gep(T,G,S,lb,binCoeff,fix_cost_matrix,var_cost_matrix,genMax,genCap,genHeat,genEff,omCost,hours,support,threads)
    end

    method_time = 0
    method_bound = "nan"
    method_ci_low = "nan"
    method_ci_high = "nan"
    cuts_std = "nan"
    cuts_nonstd = "nan"
    iterations = "nan"
    simulations = "nan"
    simulation_time = 0
    bdIters = "nan"
    sim_lower = "nan"
    sim_upper = "nan"
    outputs = [(iter = iterations, time = method_time, bb = method_bound, low = method_ci_low, high = method_ci_high, cs = cuts_std, cns = cuts_nonstd, changesS = 0, ub_final = nothing)]

    try
        method_time = @elapsed begin
            
            outputs = train_method(gep_model,
            duality_handler,
            forward_pass,
            backward_pass,
            sampling_scheme,
            time_limit,
            iter_limit,
            mipgap,
            iter_pass,
            M,
            delta,
            1,
            final_run,
            type1_prob,
            type2_prob,
            seed)

        end

        simulation_time = @elapsed begin
                simulations = SDDP.simulate(
                    # The trained model to simulate.
                    gep_model,
                    # The number of replications.
                    postSim,
                    simTime,
                    set_sim_seed = true,
                    sim_seed = 2*seed
                )
    
                objectives = map(simulations) do simulation
                    return sum(stage[:stage_objective] for stage in simulation)
                end
                
                μ, ci = SDDP.confidence_interval(objectives)
                sim_lower = μ - ci
                sim_upper = μ + ci
        end

    catch e
        method_bound   = "error"
        method_ci_low  = "error"
        method_ci_high = "error"
        cuts_std       = "error"
        cuts_nonstd    = "error"
        println("Caught an exception: $(e)")
    end

    if !isfile(filepath)
        header_row = ("class", "dual", "bpass", "fpass", "spass", "delta", "M",  "type1_prob", "type2_prob", "seed", "run", "id", "T", "scens","bdIters", "simCount", "mipgap", "maxTime", "b-time(s)", "t-time(s)", "s-time(s)", "sim-time", "iterations", "changes", "cuts_std", "cuts_nonstd", "bound", "ci_low", "ci_high", "sim_low", "sim_high", "ub_final")
        file = open(filepath, "w")
        CSV.write(file, [header_row], append = true)
        close(file)
    end
    
    for output in outputs
        row = ("gep", string(duality_handler), string(backward_pass), string(forward_pass), "InSample", delta, M, type1_prob, type2_prob, seed, reps, id, st, scens, bdIters, postSim, mipgap, time_limit, build_time, method_time, output.time, simulation_time, output.iter, output.changesS, output.cs, output.cns, output.bb, output.low, output.high, sim_lower, sim_upper, output.ub_final)
        file = open(filepath, "a")
        CSV.write(file, [row], append=true)
        close(file)    
    end


end


allInst = [[53,1,10,3], [54, 1, 10, 3], [55, 1, 10, 3]]


duals   =  [SDDP.LagrangianDuality(), SDDP.LaporteLouveauxDuality()]
bpass   =  [SDDP.DefaultMultiBackwardPass(), SDDP.AnguloMultiBackwardPass()]
fpass   =  [SDDP.DefaultMultiForwardPass(), SDDP.DefaultNestedForwardPass()]
spass   =  [SDDP.InSampleMonteCarloMultiple(), SDDP.AllSampleMonteCarloMultiple()]
gList   =  [0.01, 0.05, 0.10]
cdfinv   = [1.03, 1.28, 1.64]

current_dir = @__DIR__
folder = current_dir*"/data/"




y               = parse(Int64, ARGS[1])      #instance
z               = parse(Int64, ARGS[2])      #duality
x               = parse(Int64, ARGS[3])      #determines the forward pass and sampling scheme
q               = parse(Int64, ARGS[4])      #determines the backward pass that we are going to use
M               = parse(Int64, ARGS[5])      #number of scenario paths sampled
delta           = parse(Int64, ARGS[6])      #delta value 
threads         = parse(Int64, ARGS[7])      #threads in the solver
time_limit      = parse(Int64, ARGS[8])      #time limit on the algorithm
iter_limit      = parse(Int64, ARGS[9])      #number of iterations in the problem
final_run       = parse(Int64, ARGS[10])     #in sddip algorithm check if the entire scenario tree is traversed to compute deterministic bounds
prob            = parse(Int64, ARGS[11])     #used in tito-s stoping criterions
seed            = parse(Int64, ARGS[12])     #determines whether to set the seed or not
postSim         = parse(Int64, ARGS[13])     #number of simulations to get the upper bound




if final_run == 1
    final_run = true
else
    final_run = false
end

if seed  < 1
    seed = nothing
end


id        =  allInst[y][1]
reps      =  allInst[y][2]
st        =  allInst[y][3]
scens     =  allInst[y][4]
mipgap    = 1e-4
iter_pass = 1



filepath  = "gep_crunch"
suffix    = "_curr_$(id)_$(z)_$(q)_$(x)_$(M)_$(seed)_$(prob)_$(delta).csv"
finalpath = folder*filepath*suffix


gep_method_runs(
    folder,
    finalpath, 
    duals[z], 
    fpass[x],
    bpass[q],
    spass[x],
    reps,
    id,
    st, 
    scens,
    time_limit,
    iter_limit, 
    mipgap,
    iter_pass,
    threads,
    M,
    gList[delta],
    postSim,
    time_limit,
    final_run,
    cdfinv[prob],
    cdfinv[prob],
    seed)

